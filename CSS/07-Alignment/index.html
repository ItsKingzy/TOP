<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Alignment</title>
        <link rel="stylesheet" href="./styles.css">
    </head>
    <body>
        <h1>Alignment</h1>
        <!-- Example of Alignment -->
        <div class="container">
            <div class="item"></div>
            <div class="item"></div>
            <div class="item"></div>
        </div>

        <ul>
            <li>In the following example, we added "flex: 1;" to all the class "item" divs, this made the three elements (divs) fill the avaulable area based on its width (due to the default axis being "flex-direction: row;" given that the display is flex (i.e., "display: flex;")):</li>
            <ul>
                <li>
                    <img src="./img/flex1.png" width="400px">
                </li>
            </ul>

            <li>Removing "flex: 1" from ".item" and adding "justify-content: space-between;" to ".container" gives us the following output:</li>
            <ul>
                <li>
                    <img src="./img/justify-content-spacebetween.png" width="400px">
                </li>
            </ul>

            <li><strong>N.B.</strong>"justify-content" aligns items across the <strong>main axis</strong> (<em>currently the main axis is horizontal displaying elements in a row since "display: flex;" does this by default, <strong>however</strong>, if you change the "flex-direction" for a flex container, then the main axis would be that <u>new</u> direction that you have defined using "flex-direction"</em>).</li>

            <li>Another example we use <strong>"justify-content"</strong> property with a value of "center" which justifies our content in the center along the <u>main axis</u>, but it's not a "true center" in the sense that it will center (or align) the element along the opposite axis (<strong>or cross axis</strong>).</li>
            <ul>
                <img src="./img/only-justify-content.png" width="400px">
            </ul>

            <li>Then as a follow up, we use the <strong>"align-items"</strong> with a value of <strong>center</strong> to center the flex items along the <strong>cross axis</strong>.</li>
            <ul>
                <li><img src="./img/justify-content-and-align-content.png" width="400px"></li>
            </ul>
            
            <li><strong>N.B.:</strong> To stregthen this idea, because <strong>justify-content</strong> and <strong>align-items</strong> are based on the <u>main</u> and <u>cross</u> axis of your container, <u>their behavior changes when you change the flex-direction of a flex-container</u>.
            </li> 
            <ul>
                <li>
                    <strong>Ex:</strong> when you change flex-direction to column, justify-content aligns vertically and align-items aligns horizontally.
                </li>
            </ul>
        </ul>

        <!-- Gap -->
        <h2>Gap</h2>
        <ul>
            <li>Setting "gap" on a flex container adds a specified space between flex items (similar to adding a margin to the items themselves).</li>
            <li>Applying a "gap: 8px;" produces the following output:</li>
            <ul>
                <li><img src="./img/gap-property.png" width="400px"></li>
            </ul>
        </ul>

        <!-- Assignment Notes -->
        <h1>Assignment General Notes:</h1>
        <h2>Notes based on: <a href="https://www.joshwcomeau.com/css/interactive-guide-to-flexbox/" rel="noreferrer" target="_blank">Interactive Guide to Flexbox</a></h2>
        <ul>
            
            <li>Primary axis uses "justify-content"</li>
            <li>Cross axis uses "align-items"</li>
            <li>Difference between "justify-content" and "align-items":
                <ul>
                    <li>
                        <img src="./img/justify-content-vs-align-items.png" width="400px">
                    </li>
                </ul>
            </li>
            <li>"align-self" is a flex value that is applied to specific children inside a flex container in order to change the rules of a specific flex item</li>
            <ul>
                <li><strong>*</strong>"align-self" has the same values as "align-items"</li>
            </ul>
            <li><strong>N.B.:</strong>When we're talking about alignment in the cross axis, each item can do whatever it wants. In the primary axis, though, we can only think about how to distribute the group.</li>
            <li><strong>justify</strong> — to position something along the primary axis.</li>
            <li><strong>align</strong> — to position something along the cross axis.</li>
            <li><strong>content</strong> — a group of “stuff” that can be distributed.</li>
            <li><strong>items</strong> — single items that can be positioned individually.</li>
            <li>Hypotheical Size: It's the size an element would be, in a perfect utopian world, with nothing getting in the way. I.e., when the width of a flex item is 2000px despite not fitting to that size on a normal screen, which is where flex comes in, since the parent doesnt have room for 2000px (unless you're on an ultrawide onitor :D). Thus the child is reduced to fit.</li>

            <!-- flex-basis -->
            <li><strong>flex-basis</strong>: the Flexbox authors created a generic “size” property called flex-basis, It's like width or height, but pegged to the primary axis, like everything else. It allows us to set the hypothetical size of an element in the primary-axis direction, regardless of whether that's horizontal or vertical.</li>
            <ul>
                <li>** flex-basis is more of a <em>suggestion</em> than a hardcoded contraint unlike width.</li>
            </ul>

            <!-- flex-grow -->
            <li><strong>flex-grow</strong>: By default, elements in a Flexbox context will shrink down to their minimum comfortable size along the primary axis. <u>This often creates extra space.</u></li>
            <ul>
                <li>
                    The default value for flex-grow is 0, which means that growing is opt-in. If we want a child to gobble up any extra space in the container, we need to explicitly tell it so.
                </li>
                <li>
                    <strong>** </strong>What if multiple children set flex-grow? In this case, the extra space is divided proportionally between children based on their flex-grow value.
                </li>
            </ul>
            
            <!-- flex-shrink -->
            <li><strong>flex-shrink</strong>: The idea behind shink is that the items can shink given a shrink factor, so if some object has a flex-basis of ay 450px, but your flex container is only 600px, then shinking your container down to 300px would make the "actual size" shink so hte actual size is now 300px (filling the size of the current flex box, whereas the item with 450px wouldnt originally fill the conatiner as it's only 450px and not 600px).</li>
            <ul>
                <li><strong>N.B.:</strong> The larger the flex-shink number (integer) is, the more of a squish factor that child element can take.</li>
                <li><strong>EX:</strong></li>
                <ul>
                    <li>Alright, so: we have two children, each with a hypothetical size of 250px. The container needs to be at least 500px wide to contain these children at their hypothetical size.</li>
                    <li>Let's suppose we shrink the container to <strong>400px</strong>. Well, we can't stuff <strong>500px</strong> worth of content into a 400px bag! <u>We have a deficit of 100px</u>. Our elements will need to give up 100px total, in order for them to fit.</li>
                    <li><strong>The flex-shrink property lets us decide how that balance is paid.</strong></li>
                    <li>Like <u>flex-grow,</u> it's a ratio. By default, both children have flex-shrink: 1, and so each child pays 1/2 of the balance. They each forfeit 50px, their actual size shrinking from 250px to 200px.</li>
                    <li>Now, let's suppose we crank that first child up to flex-shrink: 3:</li>
                    <li><img src="./img/flex-shrink-locked.webp" width="400px"></li>
                    <li>We have a total deficit of 100px. Normally, each child would pay ½, but because we've tinkered with flex-shrink, the first element winds up paying ¾ (75px), and the second element pays 1/4 (25px).</li>
                    <li><strong>**</strong> Note that the absolute values don't matter, it's all about the ratio. If both children have flex-shrink: 1, each child will pay 1/2 of the total deficit. If both children are cranked up to flex-shrink: 1000, each child will pay 1000/2000 of the total deficit. Either way, it works out to the same thing.</li>
                    <li>Essentially, if one child had flex-shink 3 and the other had flex-shink 1, then the total flex-shink becomes out of 4, so element 1 has 3 so they shink 3/4's of the new continainer size, while element 2 only shrinks by 1/4 the container size.</li>
                </ul>
                <li>When we set flex-shrink to 0 on specific flex items (or children of the flex box), we essentially “opt out” of the shrinking process altogether.</li>
            </ul>

            <!-- Minimal width -->
            <li>Set <strong>minimal width (min-width)</strong> to items that overflow in a flex box, despite defining the hypothetical size and even a child with a preset minimum size (like text input, usually its 170-180px), we should redefine its min-width to 0px if we want flex shink to work on children items like text input, so they dont overflow in the flex box</li>
            <li>To add on, a good example is shrinking a flex box so far that the child items cannot shrink further.</li>
            <ul>
                <li><strong>EX:</strong>the longest unbreakable string of characters in a flex child or flex item cannot break text with ease (see example image below)</li>
                <li><img src="./img/min-size-violation.png" ></li>
            </ul>

            <!-- Gap -->
            <li><strong>Gap</strong>: the gap property allows us to create space in-between each Flexbox child (both in the main axis and the cross axis).</li>

            <!-- Auto Margins -->
            <li><strong>Auto margins</strong> will gobble up the extra space, and apply it to the element's margin</li>

            <!-- Wrapping -->
            <li>******<strong>THIS IS ALL I HAVEW BEEN LIVING UP TO!!!!!!!! It flex items in a flex container to fit the size of the box based on having multiple elements (The desconstructing pancake).</strong></li>
            <ul>
                <li>When we set "flex-wrap: wrap;", items won't shrink below their hypothetical size. At least, not when wrapping onto the next row/column is an option!</li>
            </ul>
        </ul>

        <h2>Notes based on: <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" rel="noreferrer" target="_blank">CSS Flexbox Layout Guide</a></h2>
        <ul>
            <img src="./img/00-basic-terminology.svg">
            <li>Link has some super useful content for flex boxes.</li>
        </ul>

        <h2>Helpful link for <a href="https://flexboxfroggy.com" rel="noreferrer" target="_blank">practicing flex box</a></h2>
        <ul>
            <li>"<strong>flex-flow</strong>" is a CSS property that combines flex-direction and flex-wrap (sequentially)</li>
            <ul>
                <li><strong>Ex:</strong>"flex-flow: column wrap;" makes the <u>flex-direction</u> (first argument) turn into columns, and the <u>flex-wrap</u> is the second argument which would use "wrap" in our case</li>
            </ul>
        </ul>

    </body>
</html>